# Snapshot report for `test/index.test.js`

The actual snapshot is saved in `index.test.js.snap`.

Generated by [AVA](https://ava.li).

## async/await

> input

    'let foo = async () => \'foo\''

> output

    `var foo = function foo() {␊
      return new Promise(function ($return, $error) {␊
        return $return('foo');␊
      });␊
    };`

## custom jsx pragma

> input

    `import { h } from 'preact'␊
    ␊
    const App = () => <div></div>`

> output

    `import { h } from 'preact';␊
    ␊
    var App = function App() {␊
      return h("div", null);␊
    };`

## for .. of

> input

    `for (const [i,v] of bar) {␊
      console.log(i,v)␊
    }`

> output

    `function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }␊
    ␊
    function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }␊
    ␊
    function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }␊
    ␊
    function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }␊
    ␊
    var _iteratorNormalCompletion = true;␊
    var _didIteratorError = false;␊
    var _iteratorError = undefined;␊
    ␊
    try {␊
      for (var _iterator = bar[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {␊
        var _step$value = _slicedToArray(_step.value, 2),␊
            i = _step$value[0],␊
            v = _step$value[1];␊
    ␊
        console.log(i, v);␊
      }␊
    } catch (err) {␊
      _didIteratorError = true;␊
      _iteratorError = err;␊
    } finally {␊
      try {␊
        if (!_iteratorNormalCompletion && _iterator.return != null) {␊
          _iterator.return();␊
        }␊
      } finally {␊
        if (_didIteratorError) {␊
          throw _iteratorError;␊
        }␊
      }␊
    }`

## loose mode

> input

    `const a = async () => {}␊
    ␊
    const b = {␊
      ...a␊
    }␊
    ␊
    for (const [i,v] of c.entries()) {␊
      console.log(i,v)␊
    }`

> output

    `var a = function a() {␊
      return new Promise(function ($return, $error) {␊
        return $return();␊
      });␊
    };␊
    ␊
    var b = Object.assign({}, a);␊
    ␊
    for (var _iterator = c.entries(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {␊
      var _ref;␊
    ␊
      if (_isArray) {␊
        if (_i >= _iterator.length) break;␊
        _ref = _iterator[_i++];␊
      } else {␊
        _i = _iterator.next();␊
        if (_i.done) break;␊
        _ref = _i.value;␊
      }␊
    ␊
      var _ref2 = _ref,␊
          i = _ref2[0],␊
          v = _ref2[1];␊
      console.log(i, v);␊
    }`

## modern mode

> input

    `const a = async () => {}␊
    ␊
    const b = {␊
      ...a␊
    }`

> output

    `const a = async () => {};␊
    ␊
    const b = Object.assign({}, a);`

## object rest spreading

> input

    `let foo = {␊
      ...bar␊
    }`

> output

    'var foo = Object.assign({}, bar);'

## react jsx

> input

    'const App = () => <div hehe {...props}></div>'

> output

    `function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }␊
    ␊
    var App = function App() {␊
      return React.createElement("div", _extends({␊
        hehe: true␊
      }, props));␊
    };`

## vue jsx

> input

    `const App = {␊
      render() {␊
        return <div hehe {...props}></div>␊
      }␊
    }`

> output

    `import _mergeJSXProps from "babel-helper-vue-jsx-merge-props";␊
    var App = {␊
      render: function render() {␊
        var h = arguments[0];␊
        return h("div", _mergeJSXProps([{␊
          attrs: {␊
            hehe: true␊
          }␊
        }, props]));␊
      }␊
    };`
